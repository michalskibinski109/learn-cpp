"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[958],{1351:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Basics","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Compilers Overview","href":"/learn-cpp/docs/compiler","docId":"compiler","unlisted":false},{"type":"link","label":"Linker","href":"/learn-cpp/docs/linker","docId":"linker","unlisted":false},{"type":"link","label":"Variables","href":"/learn-cpp/docs/variables","docId":"variables","unlisted":false},{"type":"link","label":"Functions","href":"/learn-cpp/docs/functions","docId":"functions","unlisted":false},{"type":"link","label":"Operators","href":"/learn-cpp/docs/operators","docId":"operators","unlisted":false},{"type":"link","label":"Ternary Operators in C++","href":"/learn-cpp/docs/ternary_operators","docId":"ternary_operators","unlisted":false},{"type":"link","label":"Const keyword","href":"/learn-cpp/docs/const","docId":"const","unlisted":false},{"type":"link","label":"Enums","href":"/learn-cpp/docs/enums","docId":"enums","unlisted":false},{"type":"link","label":"Raw pointers","href":"/learn-cpp/docs/pointers","docId":"pointers","unlisted":false},{"type":"link","label":"References in C++","href":"/learn-cpp/docs/references","docId":"references","unlisted":false},{"type":"link","label":"Strings and string literals","href":"/learn-cpp/docs/strings","docId":"strings","unlisted":false}]},{"type":"category","label":"OOP","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Classes and structures","href":"/learn-cpp/docs/classes_and_structs","docId":"classes_and_structs","unlisted":false},{"type":"link","label":"Interfaces in C++","href":"/learn-cpp/docs/interfaces","docId":"interfaces","unlisted":false},{"type":"link","label":"Visibility in classes","href":"/learn-cpp/docs/visibility","docId":"visibility","unlisted":false},{"type":"link","label":"Implicit and Explicit Conversion","href":"/learn-cpp/docs/implicit_and_explicit","docId":"implicit_and_explicit","unlisted":false}]},{"type":"category","label":"STL","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Vectors and arrays","href":"/learn-cpp/docs/vectors","docId":"vectors","unlisted":false},{"type":"link","label":"Maps","href":"/learn-cpp/docs/maps","docId":"maps","unlisted":false},{"type":"link","label":"Memory","href":"/learn-cpp/docs/memory","docId":"memory","unlisted":false}]},{"type":"category","label":"Advanced Topics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Lambdas","href":"/learn-cpp/docs/lambdas","docId":"lambdas","unlisted":false}]}]},"docs":{"classes_and_structs":{"id":"classes_and_structs","title":"Classes and structures","description":"Definition","sidebar":"tutorialSidebar"},"compiler":{"id":"compiler","title":"Compilers Overview","description":"A compiler translates source code into machine code. The process involves several stages:","sidebar":"tutorialSidebar"},"const":{"id":"const","title":"Const keyword","description":"Variables","sidebar":"tutorialSidebar"},"enums":{"id":"enums","title":"Enums","description":"Enums, short for enumerations, are a way of defining a type in C++ that consists of named constants. Enums are used when we know all possible values a variable can have, and we want to restrict it to those values to avoid errors and make the code more readable.","sidebar":"tutorialSidebar"},"functions":{"id":"functions","title":"Functions","description":"Passing class objects to functions","sidebar":"tutorialSidebar"},"headers":{"id":"headers","title":"Header files","description":"Why do we need header files?"},"implicit_and_explicit":{"id":"implicit_and_explicit","title":"Implicit and Explicit Conversion","description":"Implicit Conversion","sidebar":"tutorialSidebar"},"interfaces":{"id":"interfaces","title":"Interfaces in C++","description":"In C++, interfaces are implemented using abstract classes, defined by having at least one pure virtual function. These classes cannot be instantiated directly and must be extended by other classes. Interfaces enforce that all derived classes implement specific behaviors.","sidebar":"tutorialSidebar"},"lambdas":{"id":"lambdas","title":"Lambdas","description":"Just like in python, you can define lambdas in C++.","sidebar":"tutorialSidebar"},"linker":{"id":"linker","title":"Linker","description":"Linker is a program that takes one or more object (.obj) files generated by a compiler and combines them into a single executable program.","sidebar":"tutorialSidebar"},"maps":{"id":"maps","title":"Maps","description":"Maps in C++ are associative containers that store elements formed by a combination of a key value and a mapped value. The key value is used to uniquely identify the element, and the mapped value is the content associated with the key. Maps are a part of the Standard Template Library (STL) and are very useful for efficiently searching, inserting, and deleting elements based on keys.","sidebar":"tutorialSidebar"},"memory":{"id":"memory","title":"Memory","description":"Heap","sidebar":"tutorialSidebar"},"operators":{"id":"operators","title":"Operators","description":"=, new, delete, ==, +=, etc.","sidebar":"tutorialSidebar"},"pointers":{"id":"pointers","title":"Raw pointers","description":"Pointer is just memory address of a variable.","sidebar":"tutorialSidebar"},"references":{"id":"references","title":"References in C++","description":"What is a reference?","sidebar":"tutorialSidebar"},"strings":{"id":"strings","title":"Strings and string literals","description":"Char","sidebar":"tutorialSidebar"},"ternary_operators":{"id":"ternary_operators","title":"Ternary Operators in C++","description":"syntax:","sidebar":"tutorialSidebar"},"variables":{"id":"variables","title":"Variables","description":"- Declaration: A variable declaration provides assurance to the compiler that there exists a variable with the given type and name so that the compiler can proceed for further compilation without requiring the complete detail about the variable. A variable declaration has its meaning at the time of compilation only, the compiler needs actual variable declaration at the time of linking the program.","sidebar":"tutorialSidebar"},"vectors":{"id":"vectors","title":"Vectors and arrays","description":"A vector is a dynamic array that can grow or shrink in size. It is a sequence container that encapsulates dynamic size arrays. It is very similar to the std::array container, but it is resizable. Vectors are very efficient in terms of time complexity. They have constant time complexity for both insertion and deletion at the end of the vector. However, insertion and deletion at the beginning or in the middle of the vector have linear time complexity.","sidebar":"tutorialSidebar"},"visibility":{"id":"visibility","title":"Visibility in classes","description":"In C++, classes have three types of visibility: public, protected, and private. These keywords determine how class members are accessible from outside the class.","sidebar":"tutorialSidebar"}}}}')}}]);