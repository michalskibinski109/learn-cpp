"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[535],{9724:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=r(4848),o=r(8453);const s={},c="=, new, delete, ==, +=, etc.",a={id:"operators",title:"=, new, delete, ==, +=, etc.",description:"In C++, operators are implemented as functions. These functions can be overloaded to work with user-defined types.",source:"@site/docs/18-operators.md",sourceDirName:".",slug:"/operators",permalink:"/learn-cpp/docs/operators",draft:!1,unlisted:!1,editUrl:"https://github.com/michalskibinski109/learn-cpp/tree/main/docs/18-operators.md",tags:[],version:"current",sidebarPosition:18,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Implicit and Explicit Conversion",permalink:"/learn-cpp/docs/implicit_and_explicit"},next:{title:"Maps",permalink:"/learn-cpp/docs/maps"}},i={},l=[];function p(e){const n={admonition:"admonition",code:"code",h1:"h1",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"-new-delete---etc",children:[(0,t.jsx)(n.code,{children:"="}),", ",(0,t.jsx)(n.code,{children:"new"}),", ",(0,t.jsx)(n.code,{children:"delete"}),", ",(0,t.jsx)(n.code,{children:"=="}),", ",(0,t.jsx)(n.code,{children:"+="}),", etc."]}),"\n",(0,t.jsx)(n.admonition,{title:"It is just like dunder methods in Python",type:"tip",children:(0,t.jsx)(n.p,{children:"In C++, operators are implemented as functions. These functions can be overloaded to work with user-defined types."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct Vector2\n{\n    float x, y;\n    Vector2(float x = 0, float y = 0)\n        : x(x), y(y) {}\n\n    // Arithmetic operators\n    Vector2 operator+(const Vector2& rhs) const {\n        return Vector2(x + rhs.x, y + rhs.y);\n    }\n\n    Vector2 operator-(const Vector2& rhs) const {\n        return Vector2(x - rhs.x, y - rhs.y);\n    }\n\n    Vector2 operator*(const float scalar) const {\n        return Vector2(x * scalar, y * scalar);\n    }\n\n    Vector2 operator/(const float scalar) const {\n        return Vector2(x / scalar, y / scalar);\n    }\n\n    // Compound assignment operators\n    Vector2& operator+=(const Vector2& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n\n    Vector2& operator-=(const Vector2& rhs) {\n        x -= rhs.x;\n        y -= rhs.y;\n        return *this;\n    }\n\n    Vector2& operator*=(const float scalar) {\n        x *= scalar;\n        y *= scalar;\n        return *this;\n    }\n\n    Vector2& operator/=(const float scalar) {\n        x /= scalar;\n        y /= scalar;\n        return *this;\n    }\n\n    // Comparison operators\n    bool operator==(const Vector2& rhs) const {\n        return x == rhs.x && y == rhs.y;\n    }\n\n    bool operator!=(const Vector2& rhs) const {\n        return !(*this == rhs);\n    }\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Vector2 a(1.0f, 2.0f);\nVector2 b(2.0f, 3.0f);\n\nVector2 c = a + b; // c = (3.0f, 5.0f)\nVector2 d = a - b; // d = (-1.0f, -1.0f)\nVector2 e = a * 2.0f; // e = (2.0f, 4.0f)\nVector2 f = a / 2.0f; // f = (0.5f, 1.0f)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);