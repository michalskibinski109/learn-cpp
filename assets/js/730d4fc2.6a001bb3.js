"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[196],{8920:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>x,frontMatter:()=>a,metadata:()=>d,toc:()=>h});var s=t(4848),r=t(8453),i=t(1470),l=t(9365);const a={},c="Classes and structures",d={id:"classes_and_structs",title:"Classes and structures",description:"Definition",source:"@site/docs/9-classes_and_structs.mdx",sourceDirName:".",slug:"/classes_and_structs",permalink:"/learn-cpp/docs/classes_and_structs",draft:!1,unlisted:!1,editUrl:"https://github.com/michalskibinski109/learn-cpp/tree/main/docs/9-classes_and_structs.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"References in C++",permalink:"/learn-cpp/docs/references"},next:{title:"Visibility in classes",permalink:"/learn-cpp/docs/visibility"}},o={},h=[{value:"Definition",id:"definition",level:3},{value:"Constructor and Destructor",id:"constructor-and-destructor",level:3},{value:"Initializer list",id:"initializer-list",level:3},{value:"When to not use initializer list?",id:"when-to-not-use-initializer-list",level:4},{value:"Instantiation",id:"instantiation",level:3},{value:"On the stack",id:"on-the-stack",level:4},{value:"On the heap",id:"on-the-heap",level:4},{value:"Inheritance",id:"inheritance",level:3},{value:"Virtual methods",id:"virtual-methods",level:3},{value:"Dunder methods?",id:"dunder-methods",level:3},{value:"<code>static</code> in context of classes",id:"static-in-context-of-classes",level:3},{value:"Why do we need ctructs at all.",id:"why-do-we-need-ctructs-at-all",level:2}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"classes-and-structures",children:"Classes and structures"}),"\n",(0,s.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(i.A,{defaultValue:"class",values:[{label:"Class",value:"class"},{label:"Struct",value:"struct"}],children:[(0,s.jsx)(l.A,{value:"class",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Player {\npublic:\n        int x, y;\n        int speed;\n        \n        void Move(int xa, int ya) {\n                x += xa * speed; \n                y += ya * speed;\n        }\n};\n"})})}),(0,s.jsx)(l.A,{value:"struct",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Player {\n        int x, y;\n        int speed;\n        \n        void Move(int xa, int ya) {\n                x += xa * speed; \n                y += ya * speed;\n        }\n};\n"})})})]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["Why don't we need ",(0,s.jsx)(n.code,{children:"this"})," keyword here?"]}),(0,s.jsx)(n.p,{children:"it's not necessary to use this to access members within the object's methods, unless there's a naming conflict."})]}),"\n",(0,s.jsx)(n.h3,{id:"constructor-and-destructor",children:"Constructor and Destructor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'\nclass Player {\npublic:\n        int x, y;\n        int speed;\n\n        // Constructor\n        Player(int x, int y) {\n                this->x = x;\n                this->y = y;\n        }\n\n        // Destructor\n        ~Player() {\n                std::cout << "Player at position (" << x << ", " << y << ") is being destroyed." << std::endl;\n        }\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"initializer-list",children:"Initializer list"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Player::Player(int x, int y) : x(x), y(y) {}\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Why initializer is better?",type:"tip",children:(0,s.jsx)(n.p,{children:"Initializing member variables in the constructor body involves two steps: default construction and assignment. Using an initializer list directly assigns the provided value, which is more efficient, especially for classes with many member variables or complex objects."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Player {\npublic:\n        int x, y;\n        string name;\n\n        Player(int x, int y, string name) : x(x), y(y), name(name) {\n        }// OK\n        Player(int x, int y, string name) : x(x),  name(name),y(y) {\n        }// Not Ok, the order of the variables in the initializer list must match the order of the member variables in the class definition.\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"when-to-not-use-initializer-list",children:"When to not use initializer list?"}),"\n",(0,s.jsx)(n.p,{children:"If you need to perform some complex logic to compute the initial value of a member variable, you may need to use the constructor body to do so. However, in most cases, using an initializer list is preferred for efficiency and clarity."}),"\n",(0,s.jsx)(n.h3,{id:"instantiation",children:"Instantiation"}),"\n",(0,s.jsx)(n.h4,{id:"on-the-stack",children:"On the stack"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"{\n        Player player(5, 5);\n} // Destructor called here\n"})}),"\n",(0,s.jsx)(n.h4,{id:"on-the-heap",children:"On the heap"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Player* player = new Player(5, 5);\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Should I use stack or heap?",type:"tip",children:(0,s.jsxs)(n.p,{children:["Use the stack for objects with a short lifetime, and the heap for objects with a long lifetime. ",(0,s.jsx)(n.strong,{children:"The stack is faster and more efficient"}),", but has limited size, while the heap is slower and less efficient, but has more space."]})}),"\n",(0,s.jsx)(n.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Player {\n        public:\n        int x, y;\n        int speed;\n\n        Player(int x, int y) : x(x), y(y) {}\n\n        void Move(int xa, int ya) {\n                x += xa * speed; \n                y += ya * speed;\n        }\n};\n\nclass Enemy : public Player {\n        public:\n        Enemy(int x, int y) : Player(x, y) {}\n\n        void Attack(Player &player) {\n                player.x = 0;\n                player.y = 0;\n        }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"virtual-methods",children:"Virtual methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'class Entity {\n        public:\n        virtual void Print() const {\n                std::cout << "Entity" << std::endl;\n        }\n};\n\nclass Player : public Entity {\n        public:\n        void Print() const override {\n                std::cout << "Player" << std::endl;\n        }\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, the ",(0,s.jsx)(n.code,{children:"override"})," keyword is optional, but it is good practice to use it to indicate that the method is intended to override a virtual method in the base class. If the method does not override a virtual method in the base class, the compiler will generate an error."]}),"\n",(0,s.jsx)(n.admonition,{title:"Why do we need virtual methods?",type:"tip",children:(0,s.jsx)(n.p,{children:"Virtual methods allow derived classes to provide their own implementation of a method defined in the base class. This is useful for polymorphism, where objects of different derived classes can be treated as objects of the base class, allowing for more flexible and extensible code."})}),"\n",(0,s.jsx)(n.h3,{id:"dunder-methods",children:"Dunder methods?"}),"\n",(0,s.jsx)(n.p,{children:"In cpp they are called operator overloading."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'class Entity {\n        public:\n        // __str__\n        std::ostream& operator<<(std::ostream& stream) {\n                stream << "Entity";\n                return stream;\n        }\n};\n'})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Python"}),(0,s.jsx)(n.th,{children:"C++"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__init__"})}),(0,s.jsx)(n.td,{children:"Constructor"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__del__"})}),(0,s.jsx)(n.td,{children:"Destructor"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__str__"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"operator<<"})," (ostream operator)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__eq__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator=="})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__ne__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator!="})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__lt__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator<"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__le__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator<="})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__gt__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__ge__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator>="})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__add__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator+"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__sub__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator-"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__mul__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator*"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__truediv__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator/"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__mod__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator%"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__len__"})}),(0,s.jsxs)(n.td,{children:["Typically a member function like ",(0,s.jsx)(n.code,{children:"size()"})," or ",(0,s.jsx)(n.code,{children:"length()"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__getitem__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator[]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__setitem__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator[]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"__call__"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"operator()"})})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Please note that not all Python dunder methods have direct equivalents in C++, and vice versa. The table above lists the most common ones."}),"\n",(0,s.jsxs)(n.h3,{id:"static-in-context-of-classes",children:[(0,s.jsx)(n.code,{children:"static"})," in context of classes"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"static"})," keyword in context of classes is used to define a member that is shared by all objects of the class.  It is just like"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Player:\n    speed = 2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"why-do-we-need-ctructs-at-all",children:"Why do we need ctructs at all."}),"\n",(0,s.jsx)(n.p,{children:"Becouse of backward compatibility with C language. In C language there are no classes, so structs are used to define data structures. In C++ structs are used to define data structures as well, but they can also have member functions and access specifiers."})]})}function x(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>l});t(6540);var s=t(4164);const r={tabItem:"tabItem_Ymn6"};var i=t(4848);function l(e){let{children:n,hidden:t,className:l}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,l),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>g});var s=t(6540),r=t(4164),i=t(3104),l=t(6347),a=t(205),c=t(7485),d=t(1682),o=t(679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}}))}(t);return function(e){const n=(0,d.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function x(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const r=(0,l.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function j(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=u(e),[l,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!x({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[d,h]=p({queryString:t,groupId:r}),[j,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,o.Dv)(t);return[r,(0,s.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),y=(()=>{const e=d??j;return x({value:e,tabValues:i})?e:null})();(0,a.A)((()=>{y&&c(y)}),[y]);return{selectedValue:l,selectValue:(0,s.useCallback)((e=>{if(!x({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),m(e)}),[h,m,i]),tabValues:i}}var m=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function f(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:a}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),o=e=>{const n=e.currentTarget,t=c.indexOf(n),r=a[t].value;r!==s&&(d(n),l(r))},h=e=>{let n=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:a.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>c.push(e),onKeyDown:h,onClick:o,...i,className:(0,r.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function _(e){const n=j(e);return(0,b.jsxs)("div",{className:(0,r.A)("tabs-container",y.tabList),children:[(0,b.jsx)(f,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function g(e){const n=(0,m.A)();return(0,b.jsx)(_,{...e,children:h(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);